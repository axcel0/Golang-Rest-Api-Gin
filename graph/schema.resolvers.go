package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"Go-Lang-project-01/graph/model"
	"Go-Lang-project-01/internal/models"
	"context"
	"errors"
	"fmt"
	"strconv"

	"golang.org/x/crypto/bcrypt"
)

// Helper function to convert DB model to GraphQL model
func toGraphQLUser(user *models.User) *model.User {
	return &model.User{
		ID:        fmt.Sprintf("%d", user.ID),
		Name:      user.Name,
		Email:     user.Email,
		Role:      model.Role(user.Role),
		CreatedAt: user.CreatedAt,
		UpdatedAt: user.UpdatedAt,
	}
}

// Get user ID from context (set by auth middleware)
func getUserIDFromContext(ctx context.Context) (uint, error) {
	userID, ok := ctx.Value("userID").(uint)
	if !ok {
		return 0, errors.New("unauthorized: no user in context")
	}
	return userID, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error) {
	// Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	// Create user
	user := &models.User{
		Name:     input.Name,
		Email:    input.Email,
		Password: string(hashedPassword),
		Role:     string(models.RoleUser), // Default role
	}

	if err := r.UserRepo.Create(ctx, user); err != nil {
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	// Generate tokens
	accessToken, err := r.JWTManager.GenerateAccessToken(user.ID, user.Email, user.Role)
	if err != nil {
		return nil, fmt.Errorf("failed to generate access token: %w", err)
	}

	refreshToken, err := r.JWTManager.GenerateRefreshToken(user.ID, user.Email, user.Role)
	if err != nil {
		return nil, fmt.Errorf("failed to generate refresh token: %w", err)
	}

	return &model.AuthPayload{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
		User:         toGraphQLUser(user),
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	// Find user by email
	user, err := r.UserRepo.GetByEmail(ctx, input.Email)
	if err != nil {
		return nil, errors.New("invalid credentials")
	}

	// Verify password
	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(input.Password)); err != nil {
		return nil, errors.New("invalid credentials")
	}

	// Generate tokens
	accessToken, err := r.JWTManager.GenerateAccessToken(user.ID, user.Email, user.Role)
	if err != nil {
		return nil, fmt.Errorf("failed to generate access token: %w", err)
	}

	refreshToken, err := r.JWTManager.GenerateRefreshToken(user.ID, user.Email, user.Role)
	if err != nil {
		return nil, fmt.Errorf("failed to generate refresh token: %w", err)
	}

	return &model.AuthPayload{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
		User:         toGraphQLUser(user),
	}, nil
}

// UpdateMe is the resolver for the updateMe field.
func (r *mutationResolver) UpdateMe(ctx context.Context, input model.UpdateUserInput) (*model.User, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Get current user
	user, err := r.UserRepo.GetByID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("user not found: %w", err)
	}

	// Update fields
	if input.Name != nil {
		user.Name = *input.Name
	}
	if input.Email != nil {
		user.Email = *input.Email
	}

	if err := r.UserRepo.Update(ctx, user); err != nil {
		return nil, fmt.Errorf("failed to update user: %w", err)
	}

	return toGraphQLUser(user), nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.User, error) {
	// Check if user is admin (should be done by middleware)
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	currentUser, err := r.UserRepo.GetByID(ctx, userID)
	if err != nil {
		return nil, errors.New("unauthorized")
	}

	if currentUser.Role != string(models.RoleAdmin) && currentUser.Role != string(models.RoleSuperAdmin) {
		return nil, errors.New("forbidden: admin access required")
	}

	// Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	// Create user
	role := string(models.RoleUser)
	if input.Role != nil {
		role = string(*input.Role)
	}

	user := &models.User{
		Name:     input.Name,
		Email:    input.Email,
		Password: string(hashedPassword),
		Role:     role,
	}

	if err := r.UserRepo.Create(ctx, user); err != nil {
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	return toGraphQLUser(user), nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model.UpdateUserInput) (*model.User, error) {
	// Check admin access
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	currentUser, err := r.UserRepo.GetByID(ctx, userID)
	if err != nil {
		return nil, errors.New("unauthorized")
	}

	if currentUser.Role != string(models.RoleAdmin) && currentUser.Role != string(models.RoleSuperAdmin) {
		return nil, errors.New("forbidden: admin access required")
	}

	// Parse target user ID
	targetID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Get target user
	user, err := r.UserRepo.GetByID(ctx, uint(targetID))
	if err != nil {
		return nil, fmt.Errorf("user not found: %w", err)
	}

	// Update fields
	if input.Name != nil {
		user.Name = *input.Name
	}
	if input.Email != nil {
		user.Email = *input.Email
	}

	if err := r.UserRepo.Update(ctx, user); err != nil {
		return nil, fmt.Errorf("failed to update user: %w", err)
	}

	return toGraphQLUser(user), nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
	// Check admin access
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return false, err
	}

	currentUser, err := r.UserRepo.GetByID(ctx, userID)
	if err != nil {
		return false, errors.New("unauthorized")
	}

	if currentUser.Role != string(models.RoleAdmin) && currentUser.Role != string(models.RoleSuperAdmin) {
		return false, errors.New("forbidden: admin access required")
	}

	// Parse target user ID
	targetID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid user ID: %w", err)
	}

	// Delete user
	if err := r.UserRepo.Delete(ctx, uint(targetID)); err != nil {
		return false, fmt.Errorf("failed to delete user: %w", err)
	}

	return true, nil
}

// UpdateUserRole is the resolver for the updateUserRole field.
func (r *mutationResolver) UpdateUserRole(ctx context.Context, id string, input model.UpdateUserRoleInput) (*model.User, error) {
	// Check superadmin access
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	currentUser, err := r.UserRepo.GetByID(ctx, userID)
	if err != nil {
		return nil, errors.New("unauthorized")
	}

	if currentUser.Role != string(models.RoleSuperAdmin) {
		return nil, errors.New("forbidden: superadmin access required")
	}

	// Parse target user ID
	targetID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Get target user
	user, err := r.UserRepo.GetByID(ctx, uint(targetID))
	if err != nil {
		return nil, fmt.Errorf("user not found: %w", err)
	}

	// Update role
	user.Role = string(input.Role)

	if err := r.UserRepo.Update(ctx, user); err != nil {
		return nil, fmt.Errorf("failed to update user role: %w", err)
	}

	return toGraphQLUser(user), nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, limit *int32, offset *int32) ([]*model.User, error) {
	// Check authentication
	_, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Get all users
	dbUsers, err := r.UserRepo.GetAll(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch users: %w", err)
	}

	// Apply pagination if provided
	start := 0
	end := len(dbUsers)

	if offset != nil {
		start = int(*offset)
		if start > len(dbUsers) {
			start = len(dbUsers)
		}
	}

	if limit != nil {
		end = start + int(*limit)
		if end > len(dbUsers) {
			end = len(dbUsers)
		}
	}

	// Convert to GraphQL models
	users := make([]*model.User, 0, end-start)
	for i := start; i < end; i++ {
		users = append(users, toGraphQLUser(dbUsers[i]))
	}

	return users, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	// Check authentication
	_, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Parse user ID
	userID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Get user
	user, err := r.UserRepo.GetByID(ctx, uint(userID))
	if err != nil {
		return nil, fmt.Errorf("user not found: %w", err)
	}

	return toGraphQLUser(user), nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.UserRepo.GetByID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("user not found: %w", err)
	}

	return toGraphQLUser(user), nil
}

// UserStats is the resolver for the userStats field.
func (r *queryResolver) UserStats(ctx context.Context) (*model.UserStats, error) {
	// Check authentication
	_, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Get all users
	users, err := r.UserRepo.GetAll(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch users: %w", err)
	}

	// Count by role
	roleCounts := make(map[string]int)
	for _, user := range users {
		roleCounts[user.Role]++
	}

	// Convert to GraphQL format
	roleCountsGQL := make([]*model.RoleCount, 0, len(roleCounts))
	for role, count := range roleCounts {
		roleCountsGQL = append(roleCountsGQL, &model.RoleCount{
			Role:  model.Role(role),
			Count: int32(count),
		})
	}

	// Get recent users (last 5)
	recentCount := 5
	if len(users) < recentCount {
		recentCount = len(users)
	}
	recentUsers := make([]*model.User, 0, recentCount)
	for i := len(users) - recentCount; i < len(users); i++ {
		recentUsers = append(recentUsers, toGraphQLUser(users[i]))
	}

	return &model.UserStats{
		TotalUsers:  int32(len(users)),
		UsersByRole: roleCountsGQL,
		RecentUsers: recentUsers,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
